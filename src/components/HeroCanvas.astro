---
// Flow Field - WebGPU compute shader particle system with cursor vortex (WebGL fallback)
---

<div id="hero-canvas-container">
	<canvas id="hero-canvas"></canvas>
</div>

<style>
	#hero-canvas-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
	}

	#hero-canvas {
		display: block;
		width: 100%;
		height: 100%;
	}
</style>

<script>
	const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
	const container = document.getElementById('hero-canvas-container')!;

	// Background color values (cream)
	const bgR = 250/255;
	const bgG = 247/255;
	const bgB = 242/255;

	// Particle system constants - adjusted for mobile
	const isMobile = window.matchMedia('(max-width: 768px)').matches;
	const PARTICLE_COUNT = isMobile ? 252 : 672;
	const BASE_THICKNESS = isMobile ? 0.008775 : 0.00468;

	// Shared state for mouse (used by both WebGPU and WebGL)
	let width = 0;
	let height = 0;
	let mouseX = 0.5;
	let mouseY = 0.5;
	let targetMouseX = 0.5;
	let targetMouseY = 0.5;
	let prevMouseX = 0.5;
	let prevMouseY = 0.5;
	let mouseVelX = 0;
	let mouseVelY = 0;
	let smoothVelX = 0;
	let smoothVelY = 0;
	let vortexStrengthCurrent = 0;
	let time = 0;
	let lastTime = 0;
	let deltaTime = 0.016; // Default to ~60fps, will be updated each frame

	function lerp(a: number, b: number, t: number): number {
		return a + (b - a) * t;
	}

	function updateMouseState() {
		// Scale interpolation factors by deltaTime (normalized to 60fps)
		const dtScale = deltaTime * 60;

		prevMouseX = mouseX;
		prevMouseY = mouseY;
		const mouseLerp = 1 - Math.pow(1 - 0.08, dtScale);
		mouseX = lerp(mouseX, targetMouseX, mouseLerp);
		mouseY = lerp(mouseY, targetMouseY, mouseLerp);
		mouseVelX = (mouseX - prevMouseX) / deltaTime * 0.016; // Normalize velocity
		mouseVelY = (mouseY - prevMouseY) / deltaTime * 0.016;

		const velInertia = Math.pow(0.92, dtScale);
		const velResponse = 0.15 * dtScale;
		smoothVelX = smoothVelX * velInertia + mouseVelX * velResponse;
		smoothVelY = smoothVelY * velInertia + mouseVelY * velResponse;

		const currentVelMagnitude = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
		const targetVortexStrength = Math.min(currentVelMagnitude * 80, 2.5);
		const baseVortexInertia = currentVelMagnitude > 0.001 ? 0.08 : 0.02;
		const vortexLerp = 1 - Math.pow(1 - baseVortexInertia, dtScale);
		vortexStrengthCurrent = lerp(vortexStrengthCurrent, targetVortexStrength, vortexLerp);
	}

	// ============================================================
	// WebGL Fallback - CPU Particle System
	// ============================================================
	interface Particle {
		x: number;
		y: number;
		prevX: number;
		prevY: number;
		life: number;
		maxLife: number;
		speed: number;
		r: number;
		g: number;
		b: number;
	}

	const particles: Particle[] = [];

	// Simplex noise for WebGL fallback
	class SimplexNoise {
		private perm: number[] = [];
		private grad3 = [
			[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
			[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
			[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
		];

		constructor(seed = Math.random()) {
			const p: number[] = [];
			for (let i = 0; i < 256; i++) p[i] = i;
			let n = seed * 256;
			for (let i = 255; i > 0; i--) {
				n = (n * 16807) % 2147483647;
				const j = Math.floor((n / 2147483647) * (i + 1));
				[p[i], p[j]] = [p[j], p[i]];
			}
			for (let i = 0; i < 512; i++) {
				this.perm[i] = p[i & 255];
			}
		}

		private dot(g: number[], x: number, y: number): number {
			return g[0] * x + g[1] * y;
		}

		noise2D(x: number, y: number): number {
			const F2 = 0.5 * (Math.sqrt(3) - 1);
			const G2 = (3 - Math.sqrt(3)) / 6;
			const s = (x + y) * F2;
			const i = Math.floor(x + s);
			const j = Math.floor(y + s);
			const t = (i + j) * G2;
			const X0 = i - t;
			const Y0 = j - t;
			const x0 = x - X0;
			const y0 = y - Y0;
			const i1 = x0 > y0 ? 1 : 0;
			const j1 = x0 > y0 ? 0 : 1;
			const x1 = x0 - i1 + G2;
			const y1 = y0 - j1 + G2;
			const x2 = x0 - 1 + 2 * G2;
			const y2 = y0 - 1 + 2 * G2;
			const ii = i & 255;
			const jj = j & 255;
			let n0 = 0, n1 = 0, n2 = 0;
			let t0 = 0.5 - x0 * x0 - y0 * y0;
			if (t0 >= 0) {
				const gi0 = this.perm[ii + this.perm[jj]] % 12;
				t0 *= t0;
				n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
			}
			let t1 = 0.5 - x1 * x1 - y1 * y1;
			if (t1 >= 0) {
				const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
				t1 *= t1;
				n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
			}
			let t2 = 0.5 - x2 * x2 - y2 * y2;
			if (t2 >= 0) {
				const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
				t2 *= t2;
				n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
			}
			return 70 * (n0 + n1 + n2);
		}
	}

	const noise = new SimplexNoise(42);

	// Color palettes for WebGL fallback
	const WARM_GRAYS: [number, number, number][] = [
		[0.675, 0.659, 0.643], [0.710, 0.694, 0.678], [0.745, 0.729, 0.714],
		[0.780, 0.765, 0.749], [0.816, 0.800, 0.784],
	];
	const ORANGES: [number, number, number][] = [
		[0.698, 0.325, 0.200], [0.749, 0.373, 0.235], [0.800, 0.420, 0.271],
		[0.851, 0.467, 0.306], [0.902, 0.514, 0.341],
	];
	const TEALS: [number, number, number][] = [
		[0.220, 0.420, 0.459], [0.255, 0.459, 0.498], [0.290, 0.498, 0.537],
		[0.325, 0.537, 0.576], [0.361, 0.576, 0.616],
	];

	function computeParticleColor(colorType: number, variation: number): [number, number, number] {
		const index = Math.min(Math.floor(variation * 5), 4);
		if (colorType === 0) return WARM_GRAYS[index];
		if (colorType === 1) return ORANGES[index];
		return TEALS[index];
	}

	function lerpAngle(a: number, b: number, t: number): number {
		const diff = ((b - a + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
		return a + diff * Math.min(t, 1);
	}

	function getFlowAngle(x: number, y: number): number {
		const scale = 2.5;
		const angle = noise.noise2D(x * scale + time * 0.1, y * scale) * Math.PI * 2;
		const drift = Math.sin(y * 3 + time * 0.2) * 0.3;

		const dx = x - mouseX;
		const dy = y - mouseY;
		const dist = Math.sqrt(dx * dx + dy * dy);

		const distanceFactor = Math.exp(-dist * dist * 15);
		const vortexStrength = distanceFactor * vortexStrengthCurrent;
		const vortexAngle = Math.atan2(dy, dx) + Math.PI / 2;

		const pushStrength = Math.exp(-dist * dist * 8) * 3;
		const pushAngle = Math.atan2(smoothVelY, smoothVelX);
		const velMagnitude = Math.sqrt(smoothVelX * smoothVelX + smoothVelY * smoothVelY);

		let finalAngle = angle + drift;
		finalAngle = lerpAngle(finalAngle, vortexAngle, vortexStrength);

		if (velMagnitude > 0.001) {
			finalAngle = lerpAngle(finalAngle, pushAngle, pushStrength * Math.min(velMagnitude * 50, 1));
		}

		return finalAngle;
	}

	function createParticle(): Particle {
		const x = Math.random();
		const y = Math.random();
		const rand = Math.random();
		const colorType = rand < 0.7 ? 0 : (rand < 0.9 ? 1 : 2);
		const variation = Math.random();
		const [r, g, b] = computeParticleColor(colorType, variation);

		return {
			x, y, prevX: x, prevY: y,
			life: Math.random() * 200,
			maxLife: 150 + Math.random() * 150,
			speed: 0.3 + Math.random() * 0.4,
			r, g, b
		};
	}

	function resetParticle(p: Particle) {
		if (Math.random() < 0.5) {
			p.x = -0.05;
			p.y = Math.random();
		} else {
			p.x = Math.random();
			p.y = Math.random() < 0.5 ? -0.05 : 1.05;
		}
		p.prevX = p.x;
		p.prevY = p.y;
		p.life = 0;
		p.maxLife = 150 + Math.random() * 150;
		const rand = Math.random();
		const colorType = rand < 0.7 ? 0 : (rand < 0.9 ? 1 : 2);
		const variation = Math.random();
		const [r, g, b] = computeParticleColor(colorType, variation);
		p.r = r; p.g = g; p.b = b;
	}

	function initParticles() {
		particles.length = 0;
		for (let i = 0; i < PARTICLE_COUNT; i++) {
			particles.push(createParticle());
		}
	}

	function buildParticleData(positionData: Float32Array, colorData: Float32Array): number {
		let vertexCount = 0;
		const aspectRatio = width / height;
		const dtScale = deltaTime * 60; // Normalize to 60fps
		const CIRCLE_SEGMENTS = 8; // Number of triangles for circle

		for (let i = 0; i < particles.length; i++) {
			const p = particles[i];
			p.prevX = p.x;
			p.prevY = p.y;

			const angle = getFlowAngle(p.x, p.y);
			const speed = p.speed * 0.004 * dtScale; // Scale by deltaTime
			p.x += Math.cos(angle) * speed;
			p.y += Math.sin(angle) * speed;
			p.life += dtScale; // Scale life increment by deltaTime

			if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1 || p.life > p.maxLife) {
				resetParticle(p);
				continue;
			}

			const lifeRatio = p.life / p.maxLife;
			const fadeIn = Math.min(p.life / 20, 1);
			const fadeOut = 1 - lifeRatio * lifeRatio;
			const alpha = fadeIn * fadeOut;

			if (alpha > 0.01) {
				const dx = p.x - mouseX;
				const dy = p.y - mouseY;
				const dist = Math.sqrt(dx * dx + dy * dy);
				const proximity = Math.exp(-dist * dist * 8);

				const brighten = 1 + proximity * 0.3;
				const finalAlpha = alpha * (0.7 + proximity * 0.3);

				const thickness = BASE_THICKNESS * (1 + proximity * 0.5);
				const thicknessY = thickness * aspectRatio;

				// Calculate blended color
				const r = Math.min(p.r * brighten, 1);
				const g = Math.min(p.g * brighten, 1);
				const b = Math.min(p.b * brighten, 1);
				const invAlpha = 1.0 - finalAlpha;
				const blendedR = r * finalAlpha + bgR * invAlpha;
				const blendedG = g * finalAlpha + bgG * invAlpha;
				const blendedB = b * finalAlpha + bgB * invAlpha;

				// Draw circle at current position - trail accumulation creates lines
				const idx = vertexCount * 2;
				const cidx = vertexCount * 4;
				for (let seg = 0; seg < CIRCLE_SEGMENTS; seg++) {
					const a1 = (seg / CIRCLE_SEGMENTS) * Math.PI * 2;
					const a2 = ((seg + 1) / CIRCLE_SEGMENTS) * Math.PI * 2;

					// Center vertex
					positionData[idx + seg * 6] = p.x;
					positionData[idx + seg * 6 + 1] = p.y;
					// First edge vertex
					positionData[idx + seg * 6 + 2] = p.x + Math.cos(a1) * thickness;
					positionData[idx + seg * 6 + 3] = p.y + Math.sin(a1) * thicknessY;
					// Second edge vertex
					positionData[idx + seg * 6 + 4] = p.x + Math.cos(a2) * thickness;
					positionData[idx + seg * 6 + 5] = p.y + Math.sin(a2) * thicknessY;

					// Colors for triangle
					for (let v = 0; v < 3; v++) {
						colorData[cidx + seg * 12 + v * 4] = blendedR;
						colorData[cidx + seg * 12 + v * 4 + 1] = blendedG;
						colorData[cidx + seg * 12 + v * 4 + 2] = blendedB;
						colorData[cidx + seg * 12 + v * 4 + 3] = 1.0;
					}
				}
				vertexCount += CIRCLE_SEGMENTS * 3;
			}
		}
		return vertexCount;
	}

	// ============================================================
	// WebGPU Implementation (CPU particle sim, GPU rendering)
	// ============================================================
	async function initWebGPU(): Promise<boolean> {
		if (!navigator.gpu) {
			console.log('WebGPU not supported, falling back to WebGL');
			return false;
		}

		const adapter = await navigator.gpu.requestAdapter();
		if (!adapter) {
			console.log('No WebGPU adapter found, falling back to WebGL');
			return false;
		}

		const device = await adapter.requestDevice();
		const context = canvas.getContext('webgpu');
		if (!context) {
			console.log('Could not get WebGPU context, falling back to WebGL');
			return false;
		}

		const format = navigator.gpu.getPreferredCanvasFormat();
		context.configure({
			device,
			format,
			alphaMode: 'opaque',
		});

		// Shaders
		const lineShaderModule = device.createShaderModule({
			label: 'Line Shader',
			code: `
				struct VertexOutput {
					@builtin(position) position: vec4f,
					@location(0) color: vec4f,
				}

				@vertex
				fn vertexMain(
					@location(0) pos: vec2f,
					@location(1) color: vec4f
				) -> VertexOutput {
					var output: VertexOutput;
					output.position = vec4f(pos * 2.0 - 1.0, 0.0, 1.0);
					output.position.y *= -1.0;
					output.color = color;
					return output;
				}

				@fragment
				fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
					return input.color;
				}
			`
		});

		const fadeShaderModule = device.createShaderModule({
			label: 'Fade Shader',
			code: `
				struct Uniforms { color: vec4f }
				@group(0) @binding(0) var<uniform> uniforms: Uniforms;

				@vertex
				fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {
					return vec4f(pos, 0.0, 1.0);
				}

				@fragment
				fn fragmentMain() -> @location(0) vec4f {
					return uniforms.color;
				}
			`
		});

		const blitShaderModule = device.createShaderModule({
			label: 'Blit Shader',
			code: `
				@group(0) @binding(0) var texSampler: sampler;
				@group(0) @binding(1) var tex: texture_2d<f32>;

				struct VertexOutput {
					@builtin(position) position: vec4f,
					@location(0) uv: vec2f,
				}

				@vertex
				fn vertexMain(@location(0) pos: vec2f) -> VertexOutput {
					var output: VertexOutput;
					output.position = vec4f(pos, 0.0, 1.0);
					output.uv = (pos + 1.0) * 0.5;
					output.uv.y = 1.0 - output.uv.y;
					return output;
				}

				@fragment
				fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
					return textureSample(tex, texSampler, input.uv);
				}
			`
		});

		// Pipelines
		const linePipeline = device.createRenderPipeline({
			label: 'Line Pipeline',
			layout: 'auto',
			vertex: {
				module: lineShaderModule,
				entryPoint: 'vertexMain',
				buffers: [
					{ arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] },
					{ arrayStride: 16, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x4' }] },
				],
			},
			fragment: {
				module: lineShaderModule,
				entryPoint: 'fragmentMain',
				targets: [{ format }],
			},
			primitive: { topology: 'triangle-list' },
		});

		const fadeMultiplyPipeline = device.createRenderPipeline({
			label: 'Fade Multiply Pipeline',
			layout: 'auto',
			vertex: {
				module: fadeShaderModule,
				entryPoint: 'vertexMain',
				buffers: [{ arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }],
			},
			fragment: {
				module: fadeShaderModule,
				entryPoint: 'fragmentMain',
				targets: [{
					format,
					blend: {
						color: { srcFactor: 'dst', dstFactor: 'zero', operation: 'add' },
						alpha: { srcFactor: 'one', dstFactor: 'zero', operation: 'add' },
					},
				}],
			},
			primitive: { topology: 'triangle-list' },
		});

		const fadeAddPipeline = device.createRenderPipeline({
			label: 'Fade Add Pipeline',
			layout: 'auto',
			vertex: {
				module: fadeShaderModule,
				entryPoint: 'vertexMain',
				buffers: [{ arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }],
			},
			fragment: {
				module: fadeShaderModule,
				entryPoint: 'fragmentMain',
				targets: [{
					format,
					blend: {
						color: { srcFactor: 'one', dstFactor: 'one', operation: 'add' },
						alpha: { srcFactor: 'one', dstFactor: 'zero', operation: 'add' },
					},
				}],
			},
			primitive: { topology: 'triangle-list' },
		});

		const blitPipeline = device.createRenderPipeline({
			label: 'Blit Pipeline',
			layout: 'auto',
			vertex: {
				module: blitShaderModule,
				entryPoint: 'vertexMain',
				buffers: [{ arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }],
			},
			fragment: {
				module: blitShaderModule,
				entryPoint: 'fragmentMain',
				targets: [{ format }],
			},
			primitive: { topology: 'triangle-list' },
		});

		// Buffers
		const quadVertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
		const quadBuffer = device.createBuffer({
			size: quadVertices.byteLength,
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
		});
		device.queue.writeBuffer(quadBuffer, 0, quadVertices);

		const fadeMultiplyUniformBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
		const fadeAddUniformBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

		const fadeMultiplyBindGroup = device.createBindGroup({
			layout: fadeMultiplyPipeline.getBindGroupLayout(0),
			entries: [{ binding: 0, resource: { buffer: fadeMultiplyUniformBuffer } }],
		});

		const fadeAddBindGroup = device.createBindGroup({
			layout: fadeAddPipeline.getBindGroupLayout(0),
			entries: [{ binding: 0, resource: { buffer: fadeAddUniformBuffer } }],
		});

		const maxVertices = PARTICLE_COUNT * 24; // 6 for quad + 18 for round cap (6 triangles)
		const positionBuffer = device.createBuffer({ size: maxVertices * 8, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
		const colorBuffer = device.createBuffer({ size: maxVertices * 16, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });

		const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

		// Pre-allocated arrays (24 vertices per particle: 6 quad + 18 round cap)
		const positionData = new Float32Array(PARTICLE_COUNT * 48);
		const colorData = new Float32Array(PARTICLE_COUNT * 96);
		const fadeMultiplyData = new Float32Array(4);
		const fadeAddData = new Float32Array(4);

		let trailTexture: GPUTexture;
		let trailTextureView: GPUTextureView;
		let blitBindGroup: GPUBindGroup;

		function createTrailTexture() {
			if (trailTexture) trailTexture.destroy();
			trailTexture = device.createTexture({
				size: [canvas.width, canvas.height],
				format,
				usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
			});
			trailTextureView = trailTexture.createView();
		}

		function resize() {
			const rect = container.getBoundingClientRect();
			width = rect.width;
			height = rect.height;

			const dpr = Math.min(window.devicePixelRatio || 1, 2);
			canvas.width = width * dpr;
			canvas.height = height * dpr;

			createTrailTexture();

			blitBindGroup = device.createBindGroup({
				layout: blitPipeline.getBindGroupLayout(0),
				entries: [
					{ binding: 0, resource: sampler },
					{ binding: 1, resource: trailTextureView },
				],
			});

			const encoder = device.createCommandEncoder();
			const pass = encoder.beginRenderPass({
				colorAttachments: [{
					view: trailTextureView,
					clearValue: { r: bgR, g: bgG, b: bgB, a: 1 },
					loadOp: 'clear',
					storeOp: 'store',
				}],
			});
			pass.end();
			device.queue.submit([encoder.finish()]);
		}

		function animate(currentTime: number) {
			// Calculate delta time in seconds
			if (lastTime === 0) {
				lastTime = currentTime;
				requestAnimationFrame(animate);
				return; // Skip first frame to establish baseline
			}
			deltaTime = Math.max(0.001, Math.min((currentTime - lastTime) / 1000, 0.1)); // Clamp 1ms to 100ms
			lastTime = currentTime;

			time += deltaTime;
			updateMouseState();

			// Scale fade by deltaTime - at 60fps, keep 99.2% per frame (longer trails)
			// After 1 second at any framerate: 0.992^60 â‰ˆ 0.618 remaining
			const baseKeepPerFrame = 0.992;
			const keepAmount = Math.pow(baseKeepPerFrame, deltaTime * 60);
			const fadeAmount = 1.0 - keepAmount;

			fadeMultiplyData[0] = keepAmount;
			fadeMultiplyData[1] = keepAmount;
			fadeMultiplyData[2] = keepAmount;
			fadeMultiplyData[3] = 1.0;
			device.queue.writeBuffer(fadeMultiplyUniformBuffer, 0, fadeMultiplyData);

			fadeAddData[0] = bgR * fadeAmount;
			fadeAddData[1] = bgG * fadeAmount;
			fadeAddData[2] = bgB * fadeAmount;
			fadeAddData[3] = 1.0;
			device.queue.writeBuffer(fadeAddUniformBuffer, 0, fadeAddData);

			// Build particle data on CPU
			const vertexCount = buildParticleData(positionData, colorData);

			if (vertexCount > 0) {
				device.queue.writeBuffer(positionBuffer, 0, positionData.subarray(0, vertexCount * 2));
				device.queue.writeBuffer(colorBuffer, 0, colorData.subarray(0, vertexCount * 4));
			}

			const encoder = device.createCommandEncoder();

			// Fade multiply
			const fadeMultiplyPass = encoder.beginRenderPass({
				colorAttachments: [{ view: trailTextureView, loadOp: 'load', storeOp: 'store' }],
			});
			fadeMultiplyPass.setPipeline(fadeMultiplyPipeline);
			fadeMultiplyPass.setVertexBuffer(0, quadBuffer);
			fadeMultiplyPass.setBindGroup(0, fadeMultiplyBindGroup);
			fadeMultiplyPass.draw(6);
			fadeMultiplyPass.end();

			// Fade add
			const fadeAddPass = encoder.beginRenderPass({
				colorAttachments: [{ view: trailTextureView, loadOp: 'load', storeOp: 'store' }],
			});
			fadeAddPass.setPipeline(fadeAddPipeline);
			fadeAddPass.setVertexBuffer(0, quadBuffer);
			fadeAddPass.setBindGroup(0, fadeAddBindGroup);
			fadeAddPass.draw(6);
			fadeAddPass.end();

			// Draw particles
			if (vertexCount > 0) {
				const particlePass = encoder.beginRenderPass({
					colorAttachments: [{ view: trailTextureView, loadOp: 'load', storeOp: 'store' }],
				});
				particlePass.setPipeline(linePipeline);
				particlePass.setVertexBuffer(0, positionBuffer);
				particlePass.setVertexBuffer(1, colorBuffer);
				particlePass.draw(vertexCount);
				particlePass.end();
			}

			// Blit to screen
			const screenTexture = context.getCurrentTexture();
			const blitPass = encoder.beginRenderPass({
				colorAttachments: [{
					view: screenTexture.createView(),
					clearValue: { r: bgR, g: bgG, b: bgB, a: 1 },
					loadOp: 'clear',
					storeOp: 'store',
				}],
			});
			blitPass.setPipeline(blitPipeline);
			blitPass.setVertexBuffer(0, quadBuffer);
			blitPass.setBindGroup(0, blitBindGroup);
			blitPass.draw(6);
			blitPass.end();

			device.queue.submit([encoder.finish()]);
			requestAnimationFrame(animate);
		}

		const resizeObserver = new ResizeObserver(() => resize());
		resizeObserver.observe(container);

		document.addEventListener('mousemove', (e) => {
			const rect = container.getBoundingClientRect();
			targetMouseX = (e.clientX - rect.left) / width;
			targetMouseY = (e.clientY - rect.top) / height;
		});

		let started = false;
		const startObserver = new ResizeObserver(() => {
			if (!started) {
				started = true;
				initParticles();
				resize();
				requestAnimationFrame(animate);
				console.log('ðŸš€ WebGPU renderer active');
			}
		});
		startObserver.observe(container);

		return true;
	}

	// ============================================================
	// WebGL Fallback Implementation
	// ============================================================
	function initWebGL() {
		const glOptions = {
			alpha: true,
			premultipliedAlpha: false,
			antialias: true,
			preserveDrawingBuffer: true
		};

		let gl = canvas.getContext('webgl2', glOptions) as WebGLRenderingContext | null;
		const isWebGL2 = !!gl;
		if (!gl) {
			gl = canvas.getContext('webgl', glOptions);
		}

		if (!gl) {
			console.error('WebGL not supported');
			return;
		}

		if (isWebGL2 && 'drawingBufferColorSpace' in gl) {
			(gl as any).drawingBufferColorSpace = 'srgb';
		}

		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		const lineVertexShaderSource = `
			attribute vec2 a_position;
			attribute vec4 a_color;
			varying vec4 v_color;
			void main() {
				gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
				gl_Position.y *= -1.0;
				v_color = a_color;
			}
		`;

		const lineFragmentShaderSource = `
			precision mediump float;
			varying vec4 v_color;
			void main() {
				gl_FragColor = v_color;
			}
		`;

		const fadeVertexShaderSource = `
			attribute vec2 a_position;
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
			}
		`;

		const fadeFragmentShaderSource = `
			precision mediump float;
			uniform vec4 u_color;
			void main() {
				gl_FragColor = u_color;
			}
		`;

		function createShader(type: number, source: string): WebGLShader {
			const shader = gl!.createShader(type)!;
			gl!.shaderSource(shader, source);
			gl!.compileShader(shader);
			if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
				console.error('Shader compile error:', gl!.getShaderInfoLog(shader));
				gl!.deleteShader(shader);
				throw new Error('Shader compilation failed');
			}
			return shader;
		}

		function createProgram(vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {
			const program = gl!.createProgram()!;
			gl!.attachShader(program, vertexShader);
			gl!.attachShader(program, fragmentShader);
			gl!.linkProgram(program);
			if (!gl!.getProgramParameter(program, gl!.LINK_STATUS)) {
				console.error('Program link error:', gl!.getProgramInfoLog(program));
				throw new Error('Program linking failed');
			}
			return program;
		}

		const lineProgram = createProgram(
			createShader(gl.VERTEX_SHADER, lineVertexShaderSource),
			createShader(gl.FRAGMENT_SHADER, lineFragmentShaderSource)
		);

		const fadeProgram = createProgram(
			createShader(gl.VERTEX_SHADER, fadeVertexShaderSource),
			createShader(gl.FRAGMENT_SHADER, fadeFragmentShaderSource)
		);

		const linePositionLoc = gl.getAttribLocation(lineProgram, 'a_position');
		const lineColorLoc = gl.getAttribLocation(lineProgram, 'a_color');
		const fadePositionLoc = gl.getAttribLocation(fadeProgram, 'a_position');
		const fadeColorLoc = gl.getUniformLocation(fadeProgram, 'u_color');

		const linePositionBuffer = gl.createBuffer()!;
		const lineColorBuffer = gl.createBuffer()!;

		const fadeBuffer = gl.createBuffer()!;
		gl.bindBuffer(gl.ARRAY_BUFFER, fadeBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1, 1, -1, -1, 1,
			-1, 1, 1, -1, 1, 1
		]), gl.STATIC_DRAW);

		const positionData = new Float32Array(PARTICLE_COUNT * 48);
		const colorData = new Float32Array(PARTICLE_COUNT * 96);

		function resize() {
			const rect = container.getBoundingClientRect();
			width = rect.width;
			height = rect.height;

			const dpr = Math.min(window.devicePixelRatio || 1, 2);
			canvas.width = width * dpr;
			canvas.height = height * dpr;
			gl!.viewport(0, 0, canvas.width, canvas.height);

			// Clear to background color (resizing clears buffer to black)
			gl!.clearColor(bgR, bgG, bgB, 1);
			gl!.clear(gl!.COLOR_BUFFER_BIT);
		}

		function animate(currentTime: number) {
			// Calculate delta time in seconds
			if (lastTime === 0) {
				lastTime = currentTime;
				requestAnimationFrame(animate);
				return; // Skip first frame to establish baseline
			}
			deltaTime = Math.max(0.001, Math.min((currentTime - lastTime) / 1000, 0.1)); // Clamp 1ms to 100ms
			lastTime = currentTime;

			time += deltaTime;
			updateMouseState();

			// Scale fade by deltaTime - at 60fps, keep 99.2% per frame (longer trails)
			const baseKeepPerFrame = 0.992;
			const keepAmount = Math.pow(baseKeepPerFrame, deltaTime * 60);
			const fadeAmount = 1.0 - keepAmount;

			gl!.useProgram(fadeProgram);
			gl!.bindBuffer(gl!.ARRAY_BUFFER, fadeBuffer);
			gl!.enableVertexAttribArray(fadePositionLoc);
			gl!.vertexAttribPointer(fadePositionLoc, 2, gl!.FLOAT, false, 0, 0);

			gl!.blendFunc(gl!.DST_COLOR, gl!.ZERO);
			gl!.uniform4f(fadeColorLoc, keepAmount, keepAmount, keepAmount, 1.0);
			gl!.drawArrays(gl!.TRIANGLES, 0, 6);

			gl!.blendFunc(gl!.ONE, gl!.ONE);
			gl!.uniform4f(fadeColorLoc, bgR * fadeAmount, bgG * fadeAmount, bgB * fadeAmount, 1.0);
			gl!.drawArrays(gl!.TRIANGLES, 0, 6);

			gl!.blendFunc(gl!.SRC_ALPHA, gl!.ONE_MINUS_SRC_ALPHA);

			const vertexCount = buildParticleData(positionData, colorData);

			if (vertexCount > 0) {
				gl!.useProgram(lineProgram);

				gl!.bindBuffer(gl!.ARRAY_BUFFER, linePositionBuffer);
				gl!.bufferData(gl!.ARRAY_BUFFER, positionData.subarray(0, vertexCount * 2), gl!.DYNAMIC_DRAW);
				gl!.enableVertexAttribArray(linePositionLoc);
				gl!.vertexAttribPointer(linePositionLoc, 2, gl!.FLOAT, false, 0, 0);

				gl!.bindBuffer(gl!.ARRAY_BUFFER, lineColorBuffer);
				gl!.bufferData(gl!.ARRAY_BUFFER, colorData.subarray(0, vertexCount * 4), gl!.DYNAMIC_DRAW);
				gl!.enableVertexAttribArray(lineColorLoc);
				gl!.vertexAttribPointer(lineColorLoc, 4, gl!.FLOAT, false, 0, 0);

				gl!.drawArrays(gl!.TRIANGLES, 0, vertexCount);
			}

			requestAnimationFrame(animate);
		}

		let started = false;
		const resizeObserver = new ResizeObserver(() => {
			resize();
			if (!started) {
				started = true;
				initParticles();
				gl!.clearColor(bgR, bgG, bgB, 1);
				gl!.clear(gl!.COLOR_BUFFER_BIT);
				requestAnimationFrame(animate);
				console.log('âš ï¸ WebGL fallback renderer active (WebGPU not available)');
			}
		});

		resizeObserver.observe(container);

		document.addEventListener('mousemove', (e) => {
			const rect = container.getBoundingClientRect();
			targetMouseX = (e.clientX - rect.left) / width;
			targetMouseY = (e.clientY - rect.top) / height;
		});
	}

	// ============================================================
	// Initialize
	// ============================================================
	async function init() {
		const webgpuSuccess = await initWebGPU();
		if (!webgpuSuccess) {
			initWebGL();
		}
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', init);
	} else {
		init();
	}
</script>
