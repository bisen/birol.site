---
// Flow Field - Particles flowing through a dynamic velocity field with cursor vortex
---

<div id="hero-canvas-container">
	<canvas id="hero-canvas"></canvas>
</div>

<style>
	#hero-canvas-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
	}

	#hero-canvas {
		display: block;
		width: 100%;
		height: 100%;
	}
</style>

<script>
	const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
	const container = document.getElementById('hero-canvas-container')!;
	const ctx = canvas.getContext('2d')!;

	const colors = {
		orange: '#D95D39',
		orangeLight: '#E8886A',
		orangeFaded: 'rgba(217, 93, 57, 0.15)',
		ink: '#1A1A1A',
		cream: '#FAF7F2',
		warmGray: '#E8E4DF',
		warmGrayDark: '#D4CFC8'
	};

	let width = 0;
	let height = 0;
	let mouseX = 0.5;
	let mouseY = 0.5;
	let targetMouseX = 0.5;
	let targetMouseY = 0.5;
	let prevMouseX = 0.5;
	let prevMouseY = 0.5;
	let mouseVelX = 0;
	let mouseVelY = 0;
	let time = 0;

	// Simplex noise for flow field
	class SimplexNoise {
		private perm: number[] = [];
		private grad3 = [
			[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
			[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
			[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
		];

		constructor(seed = Math.random()) {
			const p: number[] = [];
			for (let i = 0; i < 256; i++) p[i] = i;
			let n = seed * 256;
			for (let i = 255; i > 0; i--) {
				n = (n * 16807) % 2147483647;
				const j = Math.floor((n / 2147483647) * (i + 1));
				[p[i], p[j]] = [p[j], p[i]];
			}
			for (let i = 0; i < 512; i++) {
				this.perm[i] = p[i & 255];
			}
		}

		private dot(g: number[], x: number, y: number): number {
			return g[0] * x + g[1] * y;
		}

		noise2D(x: number, y: number): number {
			const F2 = 0.5 * (Math.sqrt(3) - 1);
			const G2 = (3 - Math.sqrt(3)) / 6;
			const s = (x + y) * F2;
			const i = Math.floor(x + s);
			const j = Math.floor(y + s);
			const t = (i + j) * G2;
			const X0 = i - t;
			const Y0 = j - t;
			const x0 = x - X0;
			const y0 = y - Y0;
			const i1 = x0 > y0 ? 1 : 0;
			const j1 = x0 > y0 ? 0 : 1;
			const x1 = x0 - i1 + G2;
			const y1 = y0 - j1 + G2;
			const x2 = x0 - 1 + 2 * G2;
			const y2 = y0 - 1 + 2 * G2;
			const ii = i & 255;
			const jj = j & 255;
			let n0 = 0, n1 = 0, n2 = 0;
			let t0 = 0.5 - x0 * x0 - y0 * y0;
			if (t0 >= 0) {
				const gi0 = this.perm[ii + this.perm[jj]] % 12;
				t0 *= t0;
				n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
			}
			let t1 = 0.5 - x1 * x1 - y1 * y1;
			if (t1 >= 0) {
				const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
				t1 *= t1;
				n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
			}
			let t2 = 0.5 - x2 * x2 - y2 * y2;
			if (t2 >= 0) {
				const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
				t2 *= t2;
				n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
			}
			return 70 * (n0 + n1 + n2);
		}
	}

	const noise = new SimplexNoise(42);

	interface Particle {
		x: number;
		y: number;
		prevX: number;
		prevY: number;
		life: number;
		maxLife: number;
		speed: number;
		hue: number; // 0 = gray, 1 = orange
	}

	const particles: Particle[] = [];
	const PARTICLE_COUNT = 800;

	function createParticle(): Particle {
		const x = Math.random();
		const y = Math.random();
		return {
			x,
			y,
			prevX: x,
			prevY: y,
			life: Math.random() * 200,
			maxLife: 150 + Math.random() * 150,
			speed: 0.3 + Math.random() * 0.4,
			hue: Math.random() < 0.25 ? 1 : 0
		};
	}

	function initParticles() {
		particles.length = 0;
		for (let i = 0; i < PARTICLE_COUNT; i++) {
			particles.push(createParticle());
		}
	}

	function getFlowAngle(x: number, y: number): number {
		// Base flow from curl noise
		const scale = 2.5;
		const angle = noise.noise2D(x * scale + time * 0.1, y * scale) * Math.PI * 2;

		// Add subtle horizontal drift
		const drift = Math.sin(y * 3 + time * 0.2) * 0.3;

		// Mouse vortex influence
		const dx = x - mouseX;
		const dy = y - mouseY;
		const dist = Math.sqrt(dx * dx + dy * dy);

		// Create a vortex around cursor
		const vortexStrength = Math.exp(-dist * dist * 15) * 2.5;
		const vortexAngle = Math.atan2(dy, dx) + Math.PI / 2; // Perpendicular = rotation

		// Mouse velocity influence - push particles in direction of mouse movement
		const pushStrength = Math.exp(-dist * dist * 8) * 3;
		const pushAngle = Math.atan2(mouseVelY, mouseVelX);
		const velMagnitude = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);

		// Blend angles
		let finalAngle = angle + drift;

		// Add vortex
		finalAngle = lerpAngle(finalAngle, vortexAngle, vortexStrength);

		// Add push from mouse movement
		if (velMagnitude > 0.001) {
			finalAngle = lerpAngle(finalAngle, pushAngle, pushStrength * Math.min(velMagnitude * 50, 1));
		}

		return finalAngle;
	}

	function lerpAngle(a: number, b: number, t: number): number {
		// Properly interpolate angles
		const diff = ((b - a + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
		return a + diff * Math.min(t, 1);
	}

	function resize() {
		const rect = container.getBoundingClientRect();
		width = rect.width;
		height = rect.height;

		const dpr = Math.min(window.devicePixelRatio || 1, 2);
		canvas.width = width * dpr;
		canvas.height = height * dpr;
		ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	}

	function init() {
		resize();
		initParticles();

		window.addEventListener('resize', () => {
			resize();
			initParticles();
		});

		document.addEventListener('mousemove', (e) => {
			const rect = container.getBoundingClientRect();
			targetMouseX = (e.clientX - rect.left) / width;
			targetMouseY = (e.clientY - rect.top) / height;
		});

		// Initial fade-in of background
		ctx.fillStyle = colors.cream;
		ctx.fillRect(0, 0, width, height);

		animate();
	}

	function lerp(a: number, b: number, t: number): number {
		return a + (b - a) * t;
	}

	function animate() {
		time += 0.016;

		// Track mouse velocity
		prevMouseX = mouseX;
		prevMouseY = mouseY;
		mouseX = lerp(mouseX, targetMouseX, 0.08);
		mouseY = lerp(mouseY, targetMouseY, 0.08);
		mouseVelX = mouseX - prevMouseX;
		mouseVelY = mouseY - prevMouseY;

		// Fade effect - creates trails
		ctx.fillStyle = 'rgba(250, 247, 242, 0.035)';
		ctx.fillRect(0, 0, width, height);

		// Update and draw particles
		particles.forEach((p, i) => {
			// Store previous position
			p.prevX = p.x;
			p.prevY = p.y;

			// Get flow direction
			const angle = getFlowAngle(p.x, p.y);
			const speed = p.speed * 0.004;

			// Update position
			p.x += Math.cos(angle) * speed;
			p.y += Math.sin(angle) * speed;

			// Age particle
			p.life++;

			// Reset if out of bounds or too old
			if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1 || p.life > p.maxLife) {
				// Respawn at edge or random position
				if (Math.random() < 0.5) {
					// Respawn at left edge for horizontal flow feel
					p.x = -0.05;
					p.y = Math.random();
				} else {
					p.x = Math.random();
					p.y = Math.random() < 0.5 ? -0.05 : 1.05;
				}
				p.prevX = p.x;
				p.prevY = p.y;
				p.life = 0;
				p.maxLife = 150 + Math.random() * 150;
				p.hue = Math.random() < 0.25 ? 1 : 0;
			}

			// Draw particle trail
			const lifeRatio = p.life / p.maxLife;
			const fadeIn = Math.min(p.life / 20, 1);
			const fadeOut = 1 - Math.pow(lifeRatio, 2);
			const alpha = fadeIn * fadeOut;

			if (alpha > 0.01) {
				ctx.beginPath();
				ctx.moveTo(p.prevX * width, p.prevY * height);
				ctx.lineTo(p.x * width, p.y * height);

				// Proximity to mouse affects brightness
				const dx = p.x - mouseX;
				const dy = p.y - mouseY;
				const dist = Math.sqrt(dx * dx + dy * dy);
				const proximity = Math.exp(-dist * dist * 8);

				if (p.hue === 1) {
					// Orange particles
					const r = 217;
					const g = 93 + proximity * 40;
					const b = 57;
					ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * (0.6 + proximity * 0.4)})`;
					ctx.lineWidth = 1.5 + proximity * 1.5;
				} else {
					// Gray particles
					const gray = 180 + proximity * 30;
					ctx.strokeStyle = `rgba(${gray}, ${gray - 10}, ${gray - 15}, ${alpha * (0.35 + proximity * 0.25)})`;
					ctx.lineWidth = 1 + proximity * 0.5;
				}

				ctx.lineCap = 'round';
				ctx.stroke();
			}
		});

		// Draw subtle flow field indicators (optional - for debugging feel)
		// drawFlowField();

		requestAnimationFrame(animate);
	}

	// Optional: visualize flow field
	function drawFlowField() {
		const gridSize = 60;
		const cols = Math.ceil(width / gridSize);
		const rows = Math.ceil(height / gridSize);

		ctx.strokeStyle = 'rgba(217, 93, 57, 0.1)';
		ctx.lineWidth = 1;

		for (let i = 0; i < cols; i++) {
			for (let j = 0; j < rows; j++) {
				const x = (i + 0.5) / cols;
				const y = (j + 0.5) / rows;
				const angle = getFlowAngle(x, y);

				const px = x * width;
				const py = y * height;
				const len = 15;

				ctx.beginPath();
				ctx.moveTo(px, py);
				ctx.lineTo(px + Math.cos(angle) * len, py + Math.sin(angle) * len);
				ctx.stroke();
			}
		}
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', init);
	} else {
		init();
	}
</script>
