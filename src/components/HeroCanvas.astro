---
// Flow Field - WebGL particle system with cursor vortex
---

<div id="hero-canvas-container">
	<canvas id="hero-canvas"></canvas>
</div>

<style>
	#hero-canvas-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
	}

	#hero-canvas {
		display: block;
		width: 100%;
		height: 100%;
	}
</style>

<script>
	const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
	const container = document.getElementById('hero-canvas-container')!;

	// Background color values (cream)
	const bgR = 250/255;
	const bgG = 247/255;
	const bgB = 242/255;

	// WebGL2 setup (with fallback to WebGL1)
	const glOptions = {
		alpha: true,
		premultipliedAlpha: false,
		antialias: true,
		preserveDrawingBuffer: true
	};

	let gl = canvas.getContext('webgl2', glOptions) as WebGLRenderingContext | null;
	const isWebGL2 = !!gl;
	if (!gl) {
		gl = canvas.getContext('webgl', glOptions);
	}

	if (!gl) {
		console.error('WebGL not supported');
		throw new Error('WebGL not supported');
	}

	// Force sRGB color space on WebGL2 to prevent HDR boosting
	if (isWebGL2 && 'drawingBufferColorSpace' in gl) {
		(gl as any).drawingBufferColorSpace = 'srgb';
	}

	// Enable blending for transparency
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Shader sources
	const vertexShaderSource = `
		attribute vec2 a_position;
		attribute vec2 a_prevPosition;
		attribute vec4 a_color;
		attribute float a_size;

		varying vec4 v_color;

		void main() {
			gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
			gl_Position.y *= -1.0;
			gl_PointSize = a_size;
			v_color = a_color;
		}
	`;

	const fragmentShaderSource = `
		precision mediump float;
		varying vec4 v_color;

		void main() {
			// Soft circular point
			vec2 coord = gl_PointCoord - vec2(0.5);
			float dist = length(coord);
			float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
			gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);
		}
	`;

	// Line shaders for trails
	const lineVertexShaderSource = `
		attribute vec2 a_position;
		attribute vec4 a_color;

		varying vec4 v_color;

		void main() {
			gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
			gl_Position.y *= -1.0;
			v_color = a_color;
		}
	`;

	const lineFragmentShaderSource = `
		precision mediump float;
		varying vec4 v_color;

		void main() {
			gl_FragColor = v_color;
		}
	`;

	// Fade shader for trail effect
	const fadeVertexShaderSource = `
		attribute vec2 a_position;

		void main() {
			gl_Position = vec4(a_position, 0.0, 1.0);
		}
	`;

	const fadeFragmentShaderSource = `
		precision mediump float;
		uniform vec4 u_color;

		void main() {
			gl_FragColor = u_color;
		}
	`;

	function createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader {
		const shader = gl.createShader(type)!;
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error('Shader compile error:', gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			throw new Error('Shader compilation failed');
		}
		return shader;
	}

	function createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {
		const program = gl.createProgram()!;
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error('Program link error:', gl.getProgramInfoLog(program));
			throw new Error('Program linking failed');
		}
		return program;
	}

	// Create shader programs
	const lineProgram = createProgram(gl,
		createShader(gl, gl.VERTEX_SHADER, lineVertexShaderSource),
		createShader(gl, gl.FRAGMENT_SHADER, lineFragmentShaderSource)
	);

	const fadeProgram = createProgram(gl,
		createShader(gl, gl.VERTEX_SHADER, fadeVertexShaderSource),
		createShader(gl, gl.FRAGMENT_SHADER, fadeFragmentShaderSource)
	);

	// Get attribute and uniform locations
	const linePositionLoc = gl.getAttribLocation(lineProgram, 'a_position');
	const lineColorLoc = gl.getAttribLocation(lineProgram, 'a_color');

	const fadePositionLoc = gl.getAttribLocation(fadeProgram, 'a_position');
	const fadeColorLoc = gl.getUniformLocation(fadeProgram, 'u_color');

	// Create buffers
	const linePositionBuffer = gl.createBuffer()!;
	const lineColorBuffer = gl.createBuffer()!;

	// Fullscreen quad for fade effect
	const fadeBuffer = gl.createBuffer()!;
	gl.bindBuffer(gl.ARRAY_BUFFER, fadeBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
		-1, -1, 1, -1, -1, 1,
		-1, 1, 1, -1, 1, 1
	]), gl.STATIC_DRAW);

	// Particle system
	const PARTICLE_COUNT = 1200;

	interface Particle {
		x: number;
		y: number;
		prevX: number;
		prevY: number;
		life: number;
		maxLife: number;
		speed: number;
		colorType: number;
		variation: number;
		// Precomputed colors
		r: number;
		g: number;
		b: number;
	}

	const particles: Particle[] = [];

	// Simplex noise
	class SimplexNoise {
		private perm: number[] = [];
		private grad3 = [
			[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
			[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
			[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
		];

		constructor(seed = Math.random()) {
			const p: number[] = [];
			for (let i = 0; i < 256; i++) p[i] = i;
			let n = seed * 256;
			for (let i = 255; i > 0; i--) {
				n = (n * 16807) % 2147483647;
				const j = Math.floor((n / 2147483647) * (i + 1));
				[p[i], p[j]] = [p[j], p[i]];
			}
			for (let i = 0; i < 512; i++) {
				this.perm[i] = p[i & 255];
			}
		}

		private dot(g: number[], x: number, y: number): number {
			return g[0] * x + g[1] * y;
		}

		noise2D(x: number, y: number): number {
			const F2 = 0.5 * (Math.sqrt(3) - 1);
			const G2 = (3 - Math.sqrt(3)) / 6;
			const s = (x + y) * F2;
			const i = Math.floor(x + s);
			const j = Math.floor(y + s);
			const t = (i + j) * G2;
			const X0 = i - t;
			const Y0 = j - t;
			const x0 = x - X0;
			const y0 = y - Y0;
			const i1 = x0 > y0 ? 1 : 0;
			const j1 = x0 > y0 ? 0 : 1;
			const x1 = x0 - i1 + G2;
			const y1 = y0 - j1 + G2;
			const x2 = x0 - 1 + 2 * G2;
			const y2 = y0 - 1 + 2 * G2;
			const ii = i & 255;
			const jj = j & 255;
			let n0 = 0, n1 = 0, n2 = 0;
			let t0 = 0.5 - x0 * x0 - y0 * y0;
			if (t0 >= 0) {
				const gi0 = this.perm[ii + this.perm[jj]] % 12;
				t0 *= t0;
				n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
			}
			let t1 = 0.5 - x1 * x1 - y1 * y1;
			if (t1 >= 0) {
				const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
				t1 *= t1;
				n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
			}
			let t2 = 0.5 - x2 * x2 - y2 * y2;
			if (t2 >= 0) {
				const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
				t2 *= t2;
				n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
			}
			return 70 * (n0 + n1 + n2);
		}
	}

	const noise = new SimplexNoise(42);

	// Predefined sRGB color palettes (hex converted to 0-1 floats)
	// Warm grays - subtle warm tint
	const WARM_GRAYS: [number, number, number][] = [
		[0.675, 0.659, 0.643], // #ACA8A4
		[0.710, 0.694, 0.678], // #B5B1AD
		[0.745, 0.729, 0.714], // #BEBAB6
		[0.780, 0.765, 0.749], // #C7C3BF
		[0.816, 0.800, 0.784], // #D0CCC8
	];

	// Orange/coral accents
	const ORANGES: [number, number, number][] = [
		[0.698, 0.325, 0.200], // #B25333
		[0.749, 0.373, 0.235], // #BF5F3C
		[0.800, 0.420, 0.271], // #CC6B45
		[0.851, 0.467, 0.306], // #D9774E
		[0.902, 0.514, 0.341], // #E68357
	];

	// Teal/blue accents
	const TEALS: [number, number, number][] = [
		[0.220, 0.420, 0.459], // #386B75
		[0.255, 0.459, 0.498], // #41757F
		[0.290, 0.498, 0.537], // #4A7F89
		[0.325, 0.537, 0.576], // #538993
		[0.361, 0.576, 0.616], // #5C939D
	];

	function computeParticleColor(colorType: number, variation: number): [number, number, number] {
		// variation is 0-1, maps to palette index
		const index = Math.min(Math.floor(variation * 5), 4);

		if (colorType === 0) {
			return WARM_GRAYS[index];
		} else if (colorType === 1) {
			return ORANGES[index];
		} else {
			return TEALS[index];
		}
	}

	function createParticle(): Particle {
		const x = Math.random();
		const y = Math.random();
		// 70% gray, 20% orange, 10% teal
		const rand = Math.random();
		const colorType = rand < 0.7 ? 0 : (rand < 0.9 ? 1 : 2);
		const variation = Math.random();
		const [r, g, b] = computeParticleColor(colorType, variation);

		return {
			x, y,
			prevX: x,
			prevY: y,
			life: Math.random() * 200,
			maxLife: 150 + Math.random() * 150,
			speed: 0.3 + Math.random() * 0.4,
			colorType,
			variation,
			r, g, b
		};
	}

	function resetParticle(p: Particle) {
		if (Math.random() < 0.5) {
			p.x = -0.05;
			p.y = Math.random();
		} else {
			p.x = Math.random();
			p.y = Math.random() < 0.5 ? -0.05 : 1.05;
		}
		p.prevX = p.x;
		p.prevY = p.y;
		p.life = 0;
		p.maxLife = 150 + Math.random() * 150;
		const rand = Math.random();
		p.colorType = rand < 0.7 ? 0 : (rand < 0.9 ? 1 : 2);
		p.variation = Math.random();
		const [r, g, b] = computeParticleColor(p.colorType, p.variation);
		p.r = r;
		p.g = g;
		p.b = b;
	}

	function initParticles() {
		particles.length = 0;
		for (let i = 0; i < PARTICLE_COUNT; i++) {
			particles.push(createParticle());
		}
	}

	// Mouse state
	let width = 0;
	let height = 0;
	let mouseX = 0.5;
	let mouseY = 0.5;
	let targetMouseX = 0.5;
	let targetMouseY = 0.5;
	let prevMouseX = 0.5;
	let prevMouseY = 0.5;
	let mouseVelX = 0;
	let mouseVelY = 0;
	let smoothVelX = 0;
	let smoothVelY = 0;
	let vortexStrengthCurrent = 0;
	let time = 0;

	function lerp(a: number, b: number, t: number): number {
		return a + (b - a) * t;
	}

	function lerpAngle(a: number, b: number, t: number): number {
		const diff = ((b - a + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
		return a + diff * Math.min(t, 1);
	}

	function getFlowAngle(x: number, y: number): number {
		const scale = 2.5;
		const angle = noise.noise2D(x * scale + time * 0.1, y * scale) * Math.PI * 2;
		const drift = Math.sin(y * 3 + time * 0.2) * 0.3;

		const dx = x - mouseX;
		const dy = y - mouseY;
		const dist = Math.sqrt(dx * dx + dy * dy);

		const distanceFactor = Math.exp(-dist * dist * 15);
		const vortexStrength = distanceFactor * vortexStrengthCurrent;
		const vortexAngle = Math.atan2(dy, dx) + Math.PI / 2;

		const pushStrength = Math.exp(-dist * dist * 8) * 3;
		const pushAngle = Math.atan2(smoothVelY, smoothVelX);
		const velMagnitude = Math.sqrt(smoothVelX * smoothVelX + smoothVelY * smoothVelY);

		let finalAngle = angle + drift;
		finalAngle = lerpAngle(finalAngle, vortexAngle, vortexStrength);

		if (velMagnitude > 0.001) {
			finalAngle = lerpAngle(finalAngle, pushAngle, pushStrength * Math.min(velMagnitude * 50, 1));
		}

		return finalAngle;
	}

	function resize() {
		const rect = container.getBoundingClientRect();
		width = rect.width;
		height = rect.height;

		const dpr = Math.min(window.devicePixelRatio || 1, 2);
		canvas.width = width * dpr;
		canvas.height = height * dpr;
		gl.viewport(0, 0, canvas.width, canvas.height);
	}

	// Typed arrays for batch rendering - 6 vertices per quad (2 triangles), 2 coords each
	let positionData = new Float32Array(PARTICLE_COUNT * 12);
	let colorData = new Float32Array(PARTICLE_COUNT * 24); // 6 vertices, 4 color components each

	// Line thickness in normalized coordinates (adjusted for aspect ratio in render)
	const BASE_THICKNESS = 0.003;

	function animate() {
		time += 0.016;

		// Update mouse with inertia
		prevMouseX = mouseX;
		prevMouseY = mouseY;
		mouseX = lerp(mouseX, targetMouseX, 0.08);
		mouseY = lerp(mouseY, targetMouseY, 0.08);
		mouseVelX = mouseX - prevMouseX;
		mouseVelY = mouseY - prevMouseY;

		const velInertia = 0.92;
		const velResponse = 0.15;
		smoothVelX = smoothVelX * velInertia + mouseVelX * velResponse;
		smoothVelY = smoothVelY * velInertia + mouseVelY * velResponse;

		const currentVelMagnitude = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
		const targetVortexStrength = Math.min(currentVelMagnitude * 80, 2.5);
		const vortexInertia = currentVelMagnitude > 0.001 ? 0.08 : 0.02;
		vortexStrengthCurrent = lerp(vortexStrengthCurrent, targetVortexStrength, vortexInertia);

		// Fade effect: lerp toward background color
		// newColor = oldColor * (1 - fadeAmount) + bgColor * fadeAmount
		// Using multiply blend then additive to achieve this without alpha blending issues
		const fadeAmount = 0.012;
		const keepAmount = 1.0 - fadeAmount;

		gl.useProgram(fadeProgram);
		gl.bindBuffer(gl.ARRAY_BUFFER, fadeBuffer);
		gl.enableVertexAttribArray(fadePositionLoc);
		gl.vertexAttribPointer(fadePositionLoc, 2, gl.FLOAT, false, 0, 0);

		// First pass: multiply existing content by keepAmount
		gl.blendFunc(gl.DST_COLOR, gl.ZERO);
		gl.uniform4f(fadeColorLoc, keepAmount, keepAmount, keepAmount, 1.0);
		gl.drawArrays(gl.TRIANGLES, 0, 6);

		// Second pass: add background * fadeAmount
		gl.blendFunc(gl.ONE, gl.ONE);
		gl.uniform4f(fadeColorLoc, bgR * fadeAmount, bgG * fadeAmount, bgB * fadeAmount, 1.0);
		gl.drawArrays(gl.TRIANGLES, 0, 6);

		// Reset blend mode for particles
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		// Update particles and build vertex data
		let quadCount = 0;
		const aspectRatio = width / height;

		for (let i = 0; i < particles.length; i++) {
			const p = particles[i];

			p.prevX = p.x;
			p.prevY = p.y;

			const angle = getFlowAngle(p.x, p.y);
			const speed = p.speed * 0.004;

			p.x += Math.cos(angle) * speed;
			p.y += Math.sin(angle) * speed;
			p.life++;

			if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1 || p.life > p.maxLife) {
				resetParticle(p);
				continue;
			}

			const lifeRatio = p.life / p.maxLife;
			const fadeIn = Math.min(p.life / 20, 1);
			const fadeOut = 1 - lifeRatio * lifeRatio;
			const alpha = fadeIn * fadeOut;

			if (alpha > 0.01) {
				// Proximity brightening
				const dx = p.x - mouseX;
				const dy = p.y - mouseY;
				const dist = Math.sqrt(dx * dx + dy * dy);
				const proximity = Math.exp(-dist * dist * 8);

				const brighten = 1 + proximity * 0.3;
				const finalAlpha = alpha * (0.7 + proximity * 0.3);

				// Calculate perpendicular offset for quad thickness
				const lineAngle = Math.atan2(p.y - p.prevY, p.x - p.prevX);
				const perpX = Math.sin(lineAngle) * BASE_THICKNESS * (1 + proximity * 0.5);
				const perpY = -Math.cos(lineAngle) * BASE_THICKNESS * (1 + proximity * 0.5) * aspectRatio;

				// Build quad vertices (2 triangles)
				const idx = quadCount * 12;
				// Triangle 1
				positionData[idx] = p.prevX - perpX;
				positionData[idx + 1] = p.prevY - perpY;
				positionData[idx + 2] = p.prevX + perpX;
				positionData[idx + 3] = p.prevY + perpY;
				positionData[idx + 4] = p.x + perpX;
				positionData[idx + 5] = p.y + perpY;
				// Triangle 2
				positionData[idx + 6] = p.prevX - perpX;
				positionData[idx + 7] = p.prevY - perpY;
				positionData[idx + 8] = p.x + perpX;
				positionData[idx + 9] = p.y + perpY;
				positionData[idx + 10] = p.x - perpX;
				positionData[idx + 11] = p.y - perpY;

				const cidx = quadCount * 24;
				const r = Math.min(p.r * brighten, 1);
				const g = Math.min(p.g * brighten, 1);
				const b = Math.min(p.b * brighten, 1);

				// Blend with background in JS to avoid GPU alpha blending HDR issues
				const invAlpha = 1.0 - finalAlpha;
				const blendedR = r * finalAlpha + bgR * invAlpha;
				const blendedG = g * finalAlpha + bgG * invAlpha;
				const blendedB = b * finalAlpha + bgB * invAlpha;

				// All 6 vertices get the same color (fully opaque, pre-blended)
				for (let v = 0; v < 6; v++) {
					colorData[cidx + v * 4] = blendedR;
					colorData[cidx + v * 4 + 1] = blendedG;
					colorData[cidx + v * 4 + 2] = blendedB;
					colorData[cidx + v * 4 + 3] = 1.0;
				}

				quadCount++;
			}
		}

		// Draw all quads in one batch
		if (quadCount > 0) {
			gl.useProgram(lineProgram);

			gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, positionData.subarray(0, quadCount * 12), gl.DYNAMIC_DRAW);
			gl.enableVertexAttribArray(linePositionLoc);
			gl.vertexAttribPointer(linePositionLoc, 2, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, lineColorBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, colorData.subarray(0, quadCount * 24), gl.DYNAMIC_DRAW);
			gl.enableVertexAttribArray(lineColorLoc);
			gl.vertexAttribPointer(lineColorLoc, 4, gl.FLOAT, false, 0, 0);

			gl.drawArrays(gl.TRIANGLES, 0, quadCount * 6);
		}

		requestAnimationFrame(animate);
	}

	let animating = false;

	function init() {
		const resizeObserver = new ResizeObserver(() => {
			resize();
			if (!animating) {
				animating = true;
				initParticles();
				// Clear to cream color
				gl.clearColor(bgR, bgG, bgB, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);
				animate();
			}
		});

		resizeObserver.observe(container);

		document.addEventListener('mousemove', (e) => {
			const rect = container.getBoundingClientRect();
			targetMouseX = (e.clientX - rect.left) / width;
			targetMouseY = (e.clientY - rect.top) / height;
		});
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', init);
	} else {
		init();
	}
</script>
